# **考前知识总结**

~~想到哪写到哪~~

+ # C++ 常用库函数
    > ## ```lower_bound/upper_bound```（可用于二分）

    ```lower_bound```会找出序列中第一个大于等于x的数

    ```upper_bound```会找出序列中第一个大于x的数

    ```cpp
    lower_bound(a + 1, a + 1 + n, x);
    ```

    同样的，```lower_bound```和```upper_bound```也是可以加比较函数cmp的：

    ```cpp
    lower_bound(a + 1, a + 1 + n, x, cmp);
    ```

    它们俩使用的前提是一样的：序列是有序的

    如果要在一个下降序列里寻找一个小于x的数

    只需要把比较器改成">"：

    ```cpp
    lower_bound(a + 1, a + 1 + n, x, cmp);

    bool cmp(const int& a,const int& b){return a > b;}

    ```

    或者

    ```cpp
    lower_bound(a + 1, a + 1 + n, x, greater <int> () );
    ```

    ```**greater<int>()**```就是c++友情提供的方便的大于函数，这样就不用自己动手写一个cmp函数了

    它们的实现方式是二分查找

    返回值为指针，对于返回值我们有两种处理方式：

    ```cpp
    int p = lower_bound(···) - a;
    ```

    那么```a[p]```就是要找的```y```

    ```cpp
    int *p = lower_bound(···);
    ```


    > ## next_permutation

    ```cpp 
    #include<algorithm> 
    ```


    1.```next_permutation```下一个排列


    函数模板：```next_permutation(arr, arr+size);```

    ```arr```： 数组名 ```size```：数组元素个数

    优点：遍历一个**不重数组**的接下来全排列

    2.```prev_permutation```上一个排列

    函数模板：```prev_permutation(arr, arr+size);```

    ```arr```： 数组名 ```size```：数组元素个数

    优点：遍历一个**不重数组**的之前的全排列



    > ## ```sscanf/sprintf```

    ```sscanf()```的作用是从字符数组中读入

    同样也可以利用```sprintf()```将数据输入到```sprintf()```。
    
    ```sscanf()/sprintf()```的用法与
    ```scanf()/printf```相同，只是在参数中第一个加个字符数组。

    ```cpp
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>

    int main()
    {
    int day, year;
    char weekday[20], month[20], dtm[100];

    strcpy( dtm, "Saturday March 25 1989" );
    sscanf( dtm, "%s %s %d  %d", weekday, month, &day, &year );

    printf("%s %d, %d = %s\n", month, day, year, weekday );
        
    return(0);
    }
    ```

    > ## ```string``` 类型 基本运算

    ```cpp
    #include <iostream>
    #include <string>
    
    using namespace std;
    
    int main ()
    {
    string str1 = "runoob";
    string str2 = "google";
    string str3;
    int  len ;
    
    // 复制 str1 到 str3
    str3 = str1;
    cout << "str3 : " << str3 << endl;
    
    // 连接 str1 和 str2
    str3 = str1 + str2;
    cout << "str1 + str2 : " << str3 << endl;
    
    // 连接后，str3 的总长度
    len = str3.size();
    cout << "str3.size() :  " << len << endl;
    
    return 0;
    }
    ```

    当上面的代码被编译和执行时，它会产生下列结果：

    ```cpp
    str3 : runoob
    str1 + str2 : runoobgoogle
    str3.size() :  12
    ```

    



    > ## ```string``` 类型常用函数


    **1.	```strcpy(s1, s2);```**

        复制字符串 s2 到字符串 s1。

    **2.	```strcat(s1, s2);```**

        连接字符串 s2 到字符串 s1 的末尾。连接字符串也可以用 + 号，例如:

        ```cpp
        string str1 = "runoob";
        string str2 = "google";
        string str = str1 + str2;
        ```

    **3.	```strlen(s1);```**

        返回字符串 s1 的长度。

    **4.	```strcmp(s1, s2);```**

        如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回值小于 0；如果 s1>s2 则返回值大于 0。

    **5.	```strchr(s1, ch);```**

        返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。

    **6.	```strstr(s1, s2);```**

        返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。

+ # C++ STL 常用基础数据结构模板
    > 线性表数据结构(stack ,queue, vector)

    > 集合数据结构(set , multiset(作为映射表，平衡树))

    > 树形数据结构(priority_queue)及其重载运算符

+ # 基础算法模板
    > 高精度算法（加法，乘法）结构体封装

    > DFS, BFS模板，记忆化搜索

    > 二分查找，二分答案

+ # 进阶优化算法

    > 前缀和， 差分，（树上）

    > 离散化

    > 倍增算法

+ # 高阶数据结构模板

    > 树状数组，ST表，线段树(基础RMQ问题)

    1.ST

    ```cpp
    void init(){
        log2[0] = -1;
        for (int i = 1; i <= n;i++)
            log2[i] = log2[i >> 1] + 1;
        for (int j = 1; j <= 21;j++)
            for (int i = 1; i + (1 << j) - 1 <= n;i++)
                f[i][j] = max(f[i][j - 1], f[i + (1 << (j-1))][j - 1]);
    }

    int query(int l,int r){
        int k = log2[r - l + 1];
        return max(f[l][k], f[r - (1 << k) + 1][k]);
    }
    ```

    2.树状数组

    (1). 单点修改，区间查询

    ```cpp
        int lowbit(int x){
        return x & (-x);
    }

    void update_dot(int x,int y){
        for (; x <= n;x+=lowbit(x))
            c[x] += y;
    }

    int sum(int x){     //查询前缀和
        int ans = 0;
        for (; x; x -= lowbit(x))
            ans += c[x];
        return ans;
    }

    int sum_seg(int x,int y){
        if(x == 1)
            return sum(y);
        else
            return sum(y) - sum(x - 1);
    }
    ```

    (2). 区间修改，单点查询

    ```cpp
    void update_seg(int x,int y,long long k){
        b[x] += k, b[y + 1] -= k;
        update_dot(x, k);
        update_dot(y + 1, -k);
    }

    long long query(int x){
        long long ans = 0;
        for (; x;x-=lowbit(x))
            ans += c[x];
        return ans;
    }
    ```

    3.线段树

    ```cpp
    LL n, m, op;
    LL a[maxn], d[maxn<<2], b[maxn<<2];
    LL ans[maxn],k;

    //?建树
    void build(LL s, LL t, LL p) {
        //todo 对 [s,t] 区间建立线段树,当前根的编号为 p
        //*递归建树，边界条件为区间长度为1，此时 d[i]=a[s]=a[t]
        if(s==t){
            d[p] = a[s];
            return;
        }
        LL m = (s + t) >> 1;

        //todo 递归对左右区间建树
        //*左儿子序号为p*2，右儿子序号为p*2+1
        build(s, m, p << 1);
        build(m + 1, t, p << 1 | 1);

        //*根节点大小为左右儿子节点之和
        d[p] = d[p << 1] + d[p << 1 | 1];
    }

    //?区间查询
    LL getsum(LL l, LL r, LL s, LL t, LL p) {
        //*[l,r] 为查询区间,[s,t] 为当前节点包含的区间,p 为当前节点的编号
        if(s>=l&&t<=r)
            return d[p];
        //*当前区间为询问区间的子集时直接返回当前区间的和
        
        LL m = (s + t) >> 1;

        LL sum = 0;

        //*如果当前节点的懒标记非空,则更新当前节点两个子节点的值和懒标记值
        if (b[p]) {
            d[p << 1] += b[p] * (m - s + 1);
            d[p << 1 | 1] += b[p] * (t - m);
            b[p << 1] += b[p];            //*将标记下传给子节点
            b[p << 1 | 1] += b[p];                       
            b[p] = 0;                    //*清空当前节点的标记
        }
        //*如果左儿子代表的区间 [l,m] 与询问区间有交集,则递归查询左儿子
        if(l<=m)
            sum += getsum(l, r, s, m, p << 1);
        //*如果右儿子代表的区间 [m+1,r] 与询问区间有交集,则递归查询右儿子
        if(r>m)
            sum += getsum(l, r, m + 1, t, p << 1 | 1);

        return sum;
    }

    //?区间修改(增加)
    void update(LL l, LL r, LL c, LL s, LL t, LL p) {
        //*[l,r] 为修改区间,c 为被修改的元素的变化量,
        //*[s,t] 为当前节点包含的区间,p为当前节点的编号

        //*当前区间为修改区间的子集时直接修改当前节点的值,然后打标记,结束修改
        if(s>=l&&t<=r){
            d[p] += (t - s + 1) * c;
            b[p] += c;
            return;
        }

        LL m = (s + t) >> 1;

        //*如果当前节点的懒标记非空,则更新当前节点两个子节点的值和懒标记值
        if(b[p]&&s!=t){
            d[p << 1] += (m - s + 1) * b[p];
            d[p << 1 | 1] += (t - m) * b[p];
            //*将标记下传给子节点
            b[p << 1] += b[p];
            b[p << 1 | 1] += b[p];
            //*清空当前节点的标记
            b[p] = 0;
        }
        if(l<=m)
            update(l, r, c, s, m, p << 1);
        if(m<r)
            update(l, r, c, m + 1, t, p << 1 | 1);
        d[p] = d[p << 1] + d[p << 1 | 1];
    }
    ```

    > BST（不必需）

+ # 基础图论算法
    > 邻接表建图

    > 图上DFS/BFS

+ # 进阶图论算法
    > 拓扑排序

    > 最小生成树

    > 最短路（Dijkstra,SPFA,Floyd）

    > 图的连通性问题（连通分量，强连通分量，缩点，割点，桥，点双连通分量，边双连通分量）

+ # 高阶树上算法
    > LCA

    > 树的直径，树的重心，树的中心

+ # 动态规划
    > 经典例题各一道

+ # 字符串

    > Trie

    > KMP

+ # 数论
    > ## 快速幂

    ```cpp
    void mod(long long b, long long p, long long k) {
        while(p){
            if(p & 1)
                result =(result* b)%k;
            b = (b * b)%k;
            p >>= 1;
        }
    }
    ```

    > 质因数分解

    ```cpp
    vector<int> ret;
    vector<int> factor(int x)
    {
        for (int i = 2; i * i <= x; i++)
            while (x % i == 0)
            {
                ret.push_back(i);
                x /= i;
            }
        if (x > 1)
            ret.push_back(x);
        return ret;
    }
    ```

    > 筛法（线性筛，区间筛）

    ```cpp
    void GetPrime(int n)
    {
        memset(isPrime, 1, sizeof(isPrime));
        isPrime[1] = 0;
        for (int i = 2; i <= n; i++)
        {
            if (isPrime[i])
                prime[++cnt] = i;
            for (int j = 1; j <= cnt && i * prime[j] <= n; j++)
            {
                isPrime[i * prime[j]] = false;
                if (i % prime[j] == 0)
                    break;
            }
        }
    }
    ```

    > GCD/LCM

    > 算数基本定理

    > 同余方程

    > 欧拉函数，欧拉定理

    > 费马小定理

    > 乘法逆元

    > 中国剩余定理（CRT）

    > 组合数学（递推式）


+ # 考场技巧

    > 对拍程序

    > 快读/快写模板

    ```cpp
    inline int read()
    {
        int x=0,f=1;
        char ch=getchar();
        while (ch<'0'||ch>'9'){
            if (ch=='-') 
                f=-1;
            ch=getchar();
        }
        while (ch>='0'&&ch<='9'){
            x=x*10+ch-48;
            ch=getchar();
        }
        return x*f;
    }
    ```

    > 宏定义（如果需要）